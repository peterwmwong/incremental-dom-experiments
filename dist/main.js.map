{"version":3,"sources":["webpack:///main.js","webpack:///webpack/bootstrap 7b57655895e1e5307376","webpack:///./src/main.js","webpack:///./~/incremental-dom/index.js","webpack:///./~/incremental-dom/src/patch.js","webpack:///./~/incremental-dom/src/traversal.js","webpack:///./~/incremental-dom/src/walker.js","webpack:///./~/incremental-dom/src/node_data.js","webpack:///./~/incremental-dom/src/namespace.js","webpack:///./~/incremental-dom/src/tree_walker.js","webpack:///./~/incremental-dom/src/virtual_elements.js","webpack:///./~/node-libs-browser/~/process/browser.js","webpack:///./~/incremental-dom/src/alignment.js","webpack:///./~/incremental-dom/src/nodes.js","webpack:///./~/incremental-dom/src/attributes.js","webpack:///./src/components/App.jsx","webpack:///./src/helpers/stateful.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_incrementalDom","_incrementalDom2","_componentsAppJsx","_componentsAppJsx2","window","IncrementalDOM","origText","text","value","patch","APP","elements","alignment","traversal","elementVoid","elementOpenStart","elementOpenEnd","elementOpen","elementClose","attr","elementTrackRoot","trackRoot","elementGetRoot","getRoot","getMatchingNode","skipNextElement","nextSibling","markVisited","firstChild","parentNode","TreeWalker","walker","getWalker","setWalker","node","fn","prevWalker","getData","namespace","enterNode","data","enterTag","nodeName","exitNode","lastVisitedChild","exitTag","lastChild","removeChild","keyMap","parent","getCurrentParent","currentNode","walker_","NodeData","key","this","attrs","attrsArr","newAttrs","initData","toLowerCase","Element","getAttribute","getKey","getNodeName","SVG_NS","tag","enterNamespace","undefined","exitNamespace","getNamespaceForTag","getCurrentNamespace","stack_","doc","ownerDocument","nsStack_","prototype","length","push","pop","process","isTrackingRootElement","rootElement","alignWithDOM","updateAttribute","ATTRIBUTES_OFFSET","argsBuilder","IS_PRODUCTION","env","NODE_ENV","inAttributes","assertNotInAttributes","Error","assertInAttributes","setInAttributes","setNotInAttributes","hasChangedAttrs","unused1","unused2","unused3","var_args","attrsChanged","i","j","arguments","updateNewAttrs","updateAttributes","statics","apply","name","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","setTimeout","len","run","clearTimeout","Item","fun","array","noop","nextTick","args","Array","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","nodes","createNode","getChild","registerChild","nodeData","matches","matchingNode","existingNode","insertBefore","createElement","el","createElementNS","createTextNode","createKeyMap","map","children","count","child","getKeyMap","applyAttr","type","removeAttribute","setAttribute","applyStyle","style","String","cssText","prop","_helpersStateful","_helpersStateful2","Counter","_ref","setState","list","Number","forEach","reduce","render","statefulRender","props","newState","statefulState","curNode","state"],"mappings":"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","file":"main.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t__webpack_require__(2);\n\t\n\tvar _incrementalDom = __webpack_require__(6);\n\t\n\tvar _incrementalDom2 = _interopRequireDefault(_incrementalDom);\n\t\n\tvar _componentsAppJsx = __webpack_require__(18);\n\t\n\tvar _componentsAppJsx2 = _interopRequireDefault(_componentsAppJsx);\n\t\n\twindow.IncrementalDOM = _incrementalDom2['default'];\n\t\n\t// TODO(pwong): figure out a way to patch this in the babel-plugin-incremental-dom\n\tvar origText = _incrementalDom2['default'].text;\n\t_incrementalDom2['default'].text = function (value) {\n\t  if (value != null) origText(value);\n\t};\n\t\n\t_incrementalDom2['default'].patch(window.APP, _componentsAppJsx2['default']);\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar patch = __webpack_require__(7).patch;\n\tvar elements = __webpack_require__(13);\n\tvar alignment = __webpack_require__(15);\n\tvar traversal = __webpack_require__(8);\n\t\n\tmodule.exports = {\n\t  patch: patch,\n\t  elementVoid: elements.elementVoid,\n\t  elementOpenStart: elements.elementOpenStart,\n\t  elementOpenEnd: elements.elementOpenEnd,\n\t  elementOpen: elements.elementOpen,\n\t  elementClose: elements.elementClose,\n\t  text: elements.text,\n\t  attr: elements.attr,\n\t\n\t\n\t  elementTrackRoot: elements.trackRoot,\n\t  elementGetRoot: elements.getRoot,\n\t  getMatchingNode: alignment.getMatchingNode,\n\t  skipNextElement: traversal.nextSibling,\n\t  markVisited: traversal.markVisited\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar traversal = __webpack_require__(8),\n\t    firstChild = traversal.firstChild,\n\t    parentNode = traversal.parentNode;\n\tvar TreeWalker = __webpack_require__(12);\n\tvar walker = __webpack_require__(9),\n\t    getWalker = walker.getWalker,\n\t    setWalker = walker.setWalker;\n\t\n\t\n\t/**\n\t * Patches the document starting at el with the provided function. This function\n\t * may be called during an existing patch operation.\n\t * @param {!Element|!Document} node The Element or Document to patch.\n\t * @param {!function} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t */\n\tvar patch = function(node, fn) {\n\t  var prevWalker = getWalker();\n\t  setWalker(new TreeWalker(node));\n\t\n\t  firstChild();\n\t  fn();\n\t  parentNode();\n\t\n\t  setWalker(prevWalker);\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  patch: patch\n\t};\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar getWalker = __webpack_require__(9).getWalker;\n\tvar getData = __webpack_require__(10).getData;\n\tvar namespace = __webpack_require__(11);\n\t\n\t\n\t/**\n\t * Enters a Element, setting the current namespace for nested elements.\n\t * @param {!Element} node\n\t */\n\tvar enterNode = function(node) {\n\t  var data = getData(node);\n\t  namespace.enterTag(data.nodeName);\n\t};\n\t\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them, and unwinds the current namespace\n\t * to the previous value.\n\t * @param {!Element} node\n\t */\n\tvar exitNode = function(node) {\n\t  var data = getData(node);\n\t  var lastVisitedChild = data.lastVisitedChild;\n\t  data.lastVisitedChild = null;\n\t\n\t  namespace.exitTag(data.nodeName);\n\t\n\t  if (node.lastChild === lastVisitedChild) {\n\t    return;\n\t  }\n\t\n\t  while (node.lastChild !== lastVisitedChild) {\n\t    node.removeChild(node.lastChild);\n\t  }\n\t\n\t  // Invalidate the key map since we removed children. It will get recreated\n\t  // next time we need it.\n\t  data.keyMap = null;\n\t};\n\t\n\t\n\t/**\n\t * Marks node's parent as having visited node.\n\t * @param {!Node} node\n\t */\n\tvar markVisited = function(node) {\n\t  var walker = getWalker();\n\t  var parent = walker.getCurrentParent();\n\t  var data = getData(parent);\n\t  data.lastVisitedChild = node;\n\t};\n\t\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar firstChild = function() {\n\t  var walker = getWalker();\n\t  enterNode(walker.currentNode);\n\t  walker.firstChild();\n\t};\n\t\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextSibling = function() {\n\t  var walker = getWalker();\n\t  markVisited(walker.currentNode);\n\t  walker.nextSibling();\n\t};\n\t\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar parentNode = function() {\n\t  var walker = getWalker();\n\t  walker.parentNode();\n\t  exitNode(walker.currentNode);\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  firstChild: firstChild,\n\t  nextSibling: nextSibling,\n\t  parentNode: parentNode,\n\t  markVisited: markVisited\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * @type {TreeWalker}\n\t */\n\tvar walker_;\n\t\n\t\n\t/**\n\t * @return {TreeWalker} the current TreeWalker\n\t */\n\tvar getWalker = function() {\n\t  return walker_;\n\t};\n\t\n\t\n\t/**\n\t * Sets the current TreeWalker\n\t * @param {TreeWalker} walker\n\t */\n\tvar setWalker = function(walker) {\n\t  walker_ = walker;\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  getWalker: getWalker,\n\t  setWalker: setWalker\n\t};\n\t\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {?string} nodeName\n\t * @param {?string} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const\n\t   */\n\t  this.attrs = {};\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = {};\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key || null;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, Node>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * The last child to have been visited within the current pass.\n\t   * {?Node}\n\t   */\n\t  this.lastVisitedChild = null;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @const {string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {!Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function(node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {!Node} node The node to retrieve the data for.\n\t * @return {NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function(node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t\n\t/**\n\t * @param {?Node} node A node to get the key for.\n\t * @return {?string} The key for the Node, if applicable.\n\t */\n\tvar getKey = function(node) {\n\t  return getData(node).key;\n\t};\n\t\n\t\n\t/**\n\t * @param {?Node} node A node to get the node name for.\n\t * @return {?string} The node name for the Node, if applicable.\n\t */\n\tvar getNodeName = function(node) {\n\t  return getData(node).nodeName;\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  getData: getData,\n\t  initData: initData,\n\t  getKey: getKey,\n\t  getNodeName: getNodeName\n\t};\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar getWalker = __webpack_require__(9).getWalker;\n\t\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\t\n\t/**\n\t * Enters a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar enterTag = function(tag) {\n\t  if (tag === 'svg') {\n\t    getWalker().enterNamespace(SVG_NS);\n\t  } else if (tag === 'foreignObject') {\n\t    getWalker().enterNamespace(undefined);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Exits a tag, checking to see if it is a namespace boundary, and if so,\n\t * updates the current namespace.\n\t * @param {string} tag The tag to enter.\n\t */\n\tvar exitTag = function(tag) {\n\t  if (tag === 'svg' || tag === 'foreignObject') {\n\t    getWalker().exitNamespace();\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @return {string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function(tag) {\n\t  if (tag === 'svg') {\n\t    return SVG_NS;\n\t  }\n\t\n\t  return getWalker().getCurrentNamespace();\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  enterTag: enterTag,\n\t  exitTag: exitTag,\n\t  getNamespaceForTag: getNamespaceForTag\n\t};\n\t\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Similar to the built-in Treewalker class, but simplified and allows direct\n\t * access to modify the currentNode property.\n\t * @param {!Node} node The root Node of the subtree the walker should start\n\t *     traversing.\n\t * @constructor\n\t */\n\tfunction TreeWalker(node) {\n\t  /**\n\t   * Keeps track of the current parent node. This is necessary as the traversal\n\t   * methods may traverse past the last child and we still need a way to get\n\t   * back to the parent.\n\t   * @const @private {!Array<!Node>}\n\t   */\n\t  this.stack_ = [];\n\t\n\t  /** {?Node} */\n\t  this.currentNode = node;\n\t\n\t  /** {!Document} */\n\t  this.doc = node.ownerDocument;\n\t\n\t  /**\n\t   * Keeps track of what namespace to create new Elements in.\n\t   * @const @private {!Array<string>}\n\t   */\n\t  this.nsStack_ = [undefined];\n\t}\n\t\n\t\n\t/**\n\t * @return {!Node} The current parent of the current location in the subtree.\n\t */\n\tTreeWalker.prototype.getCurrentParent = function() {\n\t  return this.stack_[this.stack_.length - 1];\n\t};\n\t\n\t\n\t/**\n\t * @return {string} The current namespace to create Elements in.\n\t */\n\tTreeWalker.prototype.getCurrentNamespace = function() {\n\t  return this.nsStack_[this.nsStack_.length - 1];\n\t};\n\t\n\t\n\t/**\n\t * @param {string} namespace The namespace to enter.\n\t */\n\tTreeWalker.prototype.enterNamespace = function(namespace) {\n\t  this.nsStack_.push(namespace);\n\t};\n\t\n\t\n\t/**\n\t * Exits the current namespace\n\t */\n\tTreeWalker.prototype.exitNamespace = function() {\n\t  this.nsStack_.pop();\n\t};\n\t\n\t\n\t/**\n\t * Changes the current location the firstChild of the current location.\n\t */\n\tTreeWalker.prototype.firstChild = function() {\n\t  this.stack_.push(this.currentNode);\n\t  this.currentNode = this.currentNode.firstChild;\n\t};\n\t\n\t\n\t/**\n\t * Changes the current location the nextSibling of the current location.\n\t */\n\tTreeWalker.prototype.nextSibling = function() {\n\t  this.currentNode = this.currentNode.nextSibling;\n\t};\n\t\n\t\n\t/**\n\t * Changes the current location the parentNode of the current location.\n\t */\n\tTreeWalker.prototype.parentNode = function() {\n\t  this.currentNode = this.stack_.pop();\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = TreeWalker;\n\t\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar alignWithDOM = __webpack_require__(15).alignWithDOM;\n\tvar updateAttribute = __webpack_require__(17).updateAttribute;\n\tvar getData = __webpack_require__(10).getData;\n\tvar getWalker = __webpack_require__(9).getWalker;\n\tvar traversal = __webpack_require__(8),\n\t    firstChild = traversal.firstChild,\n\t    nextSibling = traversal.nextSibling,\n\t    parentNode = traversal.parentNode;\n\t\n\tvar isTrackingRootElement = false;\n\tvar rootElement;\n\t\n\tfunction trackRoot() {\n\t  isTrackingRootElement = true;\n\t  rootElement = null;\n\t}\n\t\n\tfunction getRoot() {\n\t  return rootElement;\n\t}\n\t\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @type {Array<*>}\n\t * @const\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * Verify if the script are running in production.\n\t * @type {boolean}\n\t * @const\n\t */\n\tvar IS_PRODUCTION = process.env.NODE_ENV === 'production';\n\t\n\tif (!IS_PRODUCTION) {\n\t  /**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t  var inAttributes = false;\n\t\n\t\n\t  /** Makes sure that the caller is not where attributes are expected. */\n\t  var assertNotInAttributes = function() {\n\t    if (inAttributes) {\n\t      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n\t          'they must follow a call to elementOpenStart.');\n\t    }\n\t  };\n\t\n\t\n\t  /** Makes sure that the caller is where attributes are expected. */\n\t  var assertInAttributes = function() {\n\t    if (!inAttributes) {\n\t      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n\t          'elementOpenStart must be followed by zero or more calls to attr, ' +\n\t          'then one call to elementOpenEnd.');\n\t    }\n\t  };\n\t\n\t\n\t  /** Updates the state to being in an attribute declaration. */\n\t  var setInAttributes = function() {\n\t    inAttributes = true;\n\t  };\n\t\n\t\n\t  /** Updates the state to not being in an attribute declaration. */\n\t  var setNotInAttributes = function() {\n\t    inAttributes = false;\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * Checks to see if one or more attributes have changed for a given\n\t * Element. When no attributes have changed, this function is much faster than\n\t * checking each individual argument. When attributes have changed, the overhead\n\t * of this function is minimal.\n\t *\n\t * This function is called in the context of the Element and the arguments from\n\t * elementOpen-like function so that the arguments are not de-optimized.\n\t *\n\t * @this {Element} The Element to check for changed attributes.\n\t * @param {*} unused1\n\t * @param {*} unused2\n\t * @param {*} unused3\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {boolean} True if the Element has one or more changed attributes,\n\t *     false otherwise.\n\t */\n\tvar hasChangedAttrs = function(unused1, unused2, unused3, var_args) {\n\t  var data = getData(this);\n\t  var attrsArr = data.attrsArr;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  return attrsChanged;\n\t};\n\t\n\t\n\t/**\n\t * Updates the newAttrs object for an Element.\n\t *\n\t * This function is called in the context of the Element and the arguments from\n\t * elementOpen-like function so that the arguments are not de-optimized.\n\t *\n\t * @this {Element} The Element to update newAttrs for.\n\t * @param {*} unused1\n\t * @param {*} unused2\n\t * @param {*} unused3\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Object<string, *>} The updated newAttrs object.\n\t */\n\tvar updateNewAttrs = function(unused1, unused2, unused3, var_args) {\n\t  var node = this;\n\t  var data = getData(node);\n\t  var newAttrs = data.newAttrs;\n\t\n\t  for (var attr in newAttrs) {\n\t    newAttrs[attr] = undefined;\n\t  }\n\t\n\t  for (var i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t    newAttrs[arguments[i]] = arguments[i + 1];\n\t  }\n\t\n\t  return newAttrs;\n\t};\n\t\n\t\n\t/**\n\t * Updates the attributes for a given Element.\n\t * @param {!Element} node\n\t * @param {!Object<string,*>} newAttrs The new attributes for node\n\t */\n\tvar updateAttributes = function(node, newAttrs) {\n\t  for (var attr in newAttrs) {\n\t    updateAttribute(node, attr, newAttrs[attr]);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required.\n\t * @param {string} tag The element's tag.\n\t * @param {?string} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t */\n\tvar elementOpen = function(tag, key, statics, var_args) {\n\t  if (!IS_PRODUCTION) {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = alignWithDOM(tag, key, statics);\n\t\n\t  if(isTrackingRootElement && !rootElement) {\n\t    rootElement = node;\n\t  }\n\t\n\t  if (hasChangedAttrs.apply(node, arguments)) {\n\t    var newAttrs = updateNewAttrs.apply(node, arguments);\n\t    updateAttributes(node, newAttrs);\n\t  }\n\t\n\t  firstChild();\n\t};\n\t\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function(tag, key, statics) {\n\t  if (!IS_PRODUCTION) {\n\t    assertNotInAttributes();\n\t    setInAttributes();\n\t  }\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function(name, value) {\n\t  if (!IS_PRODUCTION) {\n\t    assertInAttributes();\n\t  }\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t */\n\tvar elementOpenEnd = function() {\n\t  if (!IS_PRODUCTION) {\n\t    assertInAttributes();\n\t    setNotInAttributes();\n\t  }\n\t\n\t  elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t};\n\t\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t */\n\tvar elementClose = function(tag) {\n\t  if (!IS_PRODUCTION) {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  parentNode();\n\t  nextSibling();\n\t};\n\t\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t */\n\tvar elementVoid = function(tag, key, statics, var_args) {\n\t  if (!IS_PRODUCTION) {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  elementOpen.apply(null, arguments);\n\t  elementClose.apply(null, arguments);\n\t};\n\t\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string} value The text of the Text.\n\t */\n\tvar text = function(value) {\n\t  if (!IS_PRODUCTION) {\n\t    assertNotInAttributes();\n\t  }\n\t\n\t  var node = alignWithDOM('#text', null, value);\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    node.data = value;\n\t    data.text = value;\n\t  }\n\t\n\t  nextSibling();\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  elementOpenStart: elementOpenStart,\n\t  elementOpenEnd: elementOpenEnd,\n\t  elementOpen: elementOpen,\n\t  elementVoid: elementVoid,\n\t  elementClose: elementClose,\n\t  text: text,\n\t  attr: attr,\n\t\n\t  // WIP: for component api\n\t  trackRoot: trackRoot,\n\t  getRoot: getRoot\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            currentQueue[queueIndex].run();\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar nodes = __webpack_require__(16),\n\t    createNode = nodes.createNode,\n\t    getChild = nodes.getChild,\n\t    registerChild = nodes.registerChild;\n\tvar nodeData = __webpack_require__(10),\n\t    getKey = nodeData.getKey,\n\t    getNodeName = nodeData.getNodeName;\n\tvar getWalker = __webpack_require__(9).getWalker;\n\t\n\t\n\t/**\n\t * Checks whether or not a given node matches the specified nodeName and key.\n\t *\n\t * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function(node, nodeName, key) {\n\t  if (key) {\n\t    return key === getKey(node);\n\t  }\n\t  return nodeName === getNodeName(node);\n\t};\n\t\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {?string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string} key The key used to identify this element.\n\t * @param {?Array<*>|string} statics For an Element, this should be an array of\n\t *     name-value pairs. For a Text, this should be the text content of the\n\t *     node.\n\t * @return {!Node} The matching node.\n\t */\n\tvar alignWithDOM = function(nodeName, key, statics) {\n\t  var walker = getWalker();\n\t  var currentNode = walker.currentNode;\n\t  var parent = walker.getCurrentParent();\n\t  var matchingNode;\n\t\n\t  // Check to see if we have a node to reuse\n\t  if (currentNode && matches(currentNode, nodeName, key)) {\n\t    matchingNode = currentNode;\n\t  } else {\n\t    var existingNode = key && getChild(parent, key);\n\t\n\t    // Check to see if the node has moved within the parent or if a new one\n\t    // should be created\n\t    if (existingNode) {\n\t      matchingNode = existingNode;\n\t    } else {\n\t      matchingNode = createNode(walker.doc, nodeName, key, statics);\n\t      if (key) {\n\t        registerChild(parent, key, matchingNode);\n\t      }\n\t    }\n\t\n\t    parent.insertBefore(matchingNode, currentNode);\n\t    walker.currentNode = matchingNode;\n\t  }\n\t\n\t  return matchingNode;\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  alignWithDOM: alignWithDOM,\n\t\n\t  // WIP: for component api\n\t  getMatchingNode: function(nodeName, key) {\n\t    var walker = getWalker();\n\t    var currentNode = walker.currentNode;\n\t\n\t    // Check to see if we have a node to reuse\n\t    if(currentNode && matches(currentNode, nodeName, key)) return currentNode;\n\t\n\t    return key && getChild(walker.getCurrentParent(), key);\n\t  }\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar updateAttribute = __webpack_require__(17).updateAttribute;\n\tvar nodeData = __webpack_require__(10),\n\t    getData = nodeData.getData,\n\t    getKey = nodeData.getKey,\n\t    initData = nodeData.initData;\n\tvar getNamespaceForTag = __webpack_require__(11).getNamespaceForTag;\n\t\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {!Document} doc The document with which to create the Element.\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string} key A key to identify the Element.\n\t * @param {?Array<*>} statics An array of attribute name/value pairs of\n\t *     the static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function(doc, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag);\n\t  var el;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text.\n\t * @param {!Document} doc The document with which to create the Text.\n\t * @param {string} text The initial content of the Text.\n\t * @return {!Text}\n\t */\n\tvar createTextNode = function(doc, text) {\n\t  var node = doc.createTextNode(text);\n\t  getData(node).text = text;\n\t\n\t  return node;\n\t};\n\t\n\t\n\t/**\n\t * Creates a Node, either a Text or an Element depending on the node name\n\t * provided.\n\t * @param {!Document} doc The document with which to create the Node.\n\t * @param {string} nodeName The tag if creating an element or #text to create\n\t *     a Text.\n\t * @param {?string} key A key to identify the Element.\n\t * @param {?Array<*>|string} statics The static data to initialize the Node\n\t *     with. For an Element, an array of attribute name/value pairs of\n\t *     the static attributes for the Element. For a Text, a string with the\n\t *     initial content of the Text.\n\t * @return {!Node}\n\t */\n\tvar createNode = function(doc, nodeName, key, statics) {\n\t  if (nodeName === '#text') {\n\t    return createTextNode(doc, statics);\n\t  }\n\t\n\t  return createElement(doc, nodeName, key, statics);\n\t};\n\t\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {!Element} el\n\t * @return {!Object<string, !Node>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function(el) {\n\t  var map = {};\n\t  var children = el.children;\n\t  var count = children.length;\n\t\n\t  for (var i = 0; i < count; i += 1) {\n\t    var child = children[i];\n\t    var key = getKey(child);\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {!Element} el\n\t * @return {!Object<string,!Node>} A mapping of keys to child Nodes\n\t */\n\tvar getKeyMap = function(el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {!Element} parent\n\t * @param {?string} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function(parent, key) {\n\t  return getKeyMap(parent)[key];\n\t};\n\t\n\t\n\t/**\n\t * Registers a node as being a child. The parent will keep track of the child\n\t * using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {!Element} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function(parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  createNode: createNode,\n\t  getChild: getChild,\n\t  registerChild: registerChild\n\t};\n\t\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar getData = __webpack_require__(10).getData;\n\t\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is a object\n\t * or a function (which includes null), it is set as a property on the Element.\n\t * Otherwise, the value is set as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is a string, it is set\n\t *     as an HTML attribute, otherwise, it is set on node.\n\t */\n\tvar applyAttr = function(el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var type = typeof value;\n\t\n\t  if (value === undefined) {\n\t    el.removeAttribute(name);\n\t  } else if (type === 'object' || type === 'function') {\n\t    el[name] = value;\n\t  } else {\n\t    el.setAttribute(name, value);\n\t  }\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string|Object<string,string>} style The style to set. Either a string\n\t *     of css or an object containing property-value pairs.\n\t */\n\tvar applyStyle = function(el, style) {\n\t  if (typeof style === 'string' || style instanceof String) {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t\n\t    for (var prop in style) {\n\t      el.style[prop] = style[prop];\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is a string, it is set\n\t *     as an HTML attribute, otherwise, it is set on node.\n\t */\n\tvar updateAttribute = function(el, name, value) {\n\t  if (name === 'style') {\n\t    applyStyle(el, value);\n\t  } else {\n\t    applyAttr(el, name, value);\n\t  }\n\t};\n\t\n\t\n\t/** */\n\tmodule.exports = {\n\t  updateAttribute: updateAttribute\n\t};\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _helpersStateful = __webpack_require__(19);\n\t\n\tvar _helpersStateful2 = _interopRequireDefault(_helpersStateful);\n\t\n\t// import TodoItem   from './TodoItem.jsx';\n\t// import TodoFooter from './TodoFooter.jsx';\n\t//\n\t// function handleNewTodoKeyDown(){ }\n\t// function handleToggleAll(){ }\n\t// function handleToggle(){ }\n\t// function handleDestroy(){ }\n\t//\n\t// export default ()=>{\n\t//   let activeTodoCount = 0;\n\t//   let shownTodos      = [{id:1, completed:false, title:'Hilaaarious'}];\n\t//\n\t//   <div>\n\t// \t\t<header class=\"header\">\n\t// \t\t\t<h1>todos</h1>\n\t// \t\t\t<input\n\t// \t\t\t\tref=\"newField\"\n\t// \t\t\t\tclass=\"new-todo\"\n\t// \t\t\t\tplaceholder=\"What needs to be done?\"\n\t// \t\t\t\tonKeyDown={handleNewTodoKeyDown}\n\t// \t\t\t\tautoFocus={true} />\n\t// \t\t</header>\n\t// \t\t<section class=\"main\">\n\t// \t\t\t<input\n\t// \t\t\t\tclass=\"toggle-all\"\n\t// \t\t\t\ttype=\"checkbox\"\n\t// \t\t\t\tonChange={handleToggleAll}\n\t// \t\t\t\tchecked={activeTodoCount === 0} />\n\t// \t\t\t<ul class=\"todo-list\">\n\t//         {shownTodos.forEach(todo=>\n\t//           <TodoItem todo={todo} onToggle={handleToggle} onDestroy={handleDestroy}/>\n\t//         )}\n\t// \t\t\t</ul>\n\t// \t\t</section>\n\t//     <TodoFooter />\n\t//   </div>;\n\t// };\n\t\n\tvar Counter = _helpersStateful2['default'](function (count) {\n\t  return count || 0;\n\t}, function (_ref, count, setState) {\n\t  var key = _ref.key;\n\t  var name = _ref.name;\n\t\n\t  IncrementalDOM.elementOpen('div', key);IncrementalDOM.elementOpen('span');IncrementalDOM.text(count);IncrementalDOM.text(' ');IncrementalDOM.text(name);IncrementalDOM.text(' ');IncrementalDOM.elementClose('span');IncrementalDOM.elementOpen('button', null, null, 'onclick', function () {\n\t      return setState(++count);\n\t    });IncrementalDOM.text('Hello World');IncrementalDOM.elementClose('button');IncrementalDOM.elementClose('div');;\n\t});\n\t\n\tvar Counter2 = function Counter2(_ref2, count, setState) {\n\t  var key = _ref2.key;\n\t  var name = _ref2.name;\n\t\n\t  IncrementalDOM.elementOpen('div', key);IncrementalDOM.elementOpen('span');IncrementalDOM.text(count || 'hello');IncrementalDOM.text(' ');IncrementalDOM.text(name);IncrementalDOM.text(' ');IncrementalDOM.elementClose('span');IncrementalDOM.elementOpen('button', null, null, 'onclick', function () {\n\t      return setState(++count);\n\t    });IncrementalDOM.text('Hello World');IncrementalDOM.elementClose('button');IncrementalDOM.elementClose('div');;\n\t};\n\t\n\tvar list = Array.apply(null, { length: 100 }).map(Number.call, Number);\n\t\n\texports['default'] = function () {\n\t  IncrementalDOM.elementOpen('div');IncrementalDOM.text(list.forEach(function (i) {\n\t      Counter({\n\t        key: i,\n\t        name: 'C' + i\n\t      });;\n\t    }));IncrementalDOM.elementClose('div');;\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\tAllows defining stateful components\n\t\n\tTODO:\n\t\n\t- Inject key into component element render\n\t\n\tRequirements:\n\t\n\t- Handle initial render\n\t- Handle parent re-render\n\t- Handle component re-render (setState called)\n\t\n\t*/\n\t\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports[\"default\"] = function (reduce, render) {\n\t  var nodeName = undefined;\n\t\n\t  function statefulRender(props, node) {\n\t    // Called by component to set the new state and\n\t    // re-render the component without re-rendering\n\t    // the whole document\n\t    function setState(newState) {\n\t      var parentNode = node.parentNode;\n\t\n\t      node.statefulState = newState;\n\t      IncrementalDOM.patch(parentNode, function () {\n\t        // Skip over all siblings before component's element\n\t        var curNode = parentNode.firstChild;\n\t        while (curNode !== node) {\n\t          IncrementalDOM.skipNextElement();\n\t          curNode = curNode.nextSibling;\n\t        }\n\t\n\t        render(props, newState, setState);\n\t\n\t        // Mark the last child as visited so IncrementalDOM\n\t        // doesn't truncate all sibling elements after the\n\t        // component's element\n\t        IncrementalDOM.markVisited(parentNode.lastChild);\n\t      });\n\t    }\n\t\n\t    var key = props && props.key;\n\t\n\t    // Try to find component's element\n\t    node = node || nodeName && IncrementalDOM.getMatchingNode(nodeName, key);\n\t\n\t    // Initial render\n\t    if (!node) {\n\t      // TODO(pwong): Call with props and previous state\n\t      var state = reduce();\n\t\n\t      // Tell IncrementalDOM to track the root (first)\n\t      // element rendered.  This will be considered the\n\t      // component's element.\n\t      IncrementalDOM.elementTrackRoot();\n\t      render(props, state, setState);\n\t      node = IncrementalDOM.elementGetRoot();\n\t      // debugger;\n\t      // nodeName = node.nodeName.toLowerCase();\n\t      node.statefulState = state;\n\t    }\n\t    // Parent re-render\n\t    else {\n\t      render(props, node.statefulState, setState);\n\t    }\n\t  }\n\t\n\t  return statefulRender;\n\t};\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** main.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7b57655895e1e5307376\n **/","import 'todomvc-app-css/index.css';\n\nimport IncrementalDOM from 'incremental-dom';\nimport App            from './components/App.jsx';\n\nwindow.IncrementalDOM = IncrementalDOM;\n\n// TODO(pwong): figure out a way to patch this in the babel-plugin-incremental-dom\nconst origText = IncrementalDOM.text;\nIncrementalDOM.text = function(value){ if(value != null) origText(value); };\n\nIncrementalDOM.patch(window.APP, App);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar patch = require('./src/patch').patch;\nvar elements = require('./src/virtual_elements');\nvar alignment = require('./src/alignment');\nvar traversal = require('./src/traversal');\n\nmodule.exports = {\n  patch: patch,\n  elementVoid: elements.elementVoid,\n  elementOpenStart: elements.elementOpenStart,\n  elementOpenEnd: elements.elementOpenEnd,\n  elementOpen: elements.elementOpen,\n  elementClose: elements.elementClose,\n  text: elements.text,\n  attr: elements.attr,\n\n\n  elementTrackRoot: elements.trackRoot,\n  elementGetRoot: elements.getRoot,\n  getMatchingNode: alignment.getMatchingNode,\n  skipNextElement: traversal.nextSibling,\n  markVisited: traversal.markVisited\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/index.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar traversal = require('./traversal'),\n    firstChild = traversal.firstChild,\n    parentNode = traversal.parentNode;\nvar TreeWalker = require('./tree_walker');\nvar walker = require('./walker'),\n    getWalker = walker.getWalker,\n    setWalker = walker.setWalker;\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!Document} node The Element or Document to patch.\n * @param {!function} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n */\nvar patch = function(node, fn) {\n  var prevWalker = getWalker();\n  setWalker(new TreeWalker(node));\n\n  firstChild();\n  fn();\n  parentNode();\n\n  setWalker(prevWalker);\n};\n\n\n/** */\nmodule.exports = {\n  patch: patch\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/patch.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getWalker = require('./walker').getWalker;\nvar getData = require('./node_data').getData;\nvar namespace = require('./namespace');\n\n\n/**\n * Enters a Element, setting the current namespace for nested elements.\n * @param {!Element} node\n */\nvar enterNode = function(node) {\n  var data = getData(node);\n  namespace.enterTag(data.nodeName);\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them, and unwinds the current namespace\n * to the previous value.\n * @param {!Element} node\n */\nvar exitNode = function(node) {\n  var data = getData(node);\n  var lastVisitedChild = data.lastVisitedChild;\n  data.lastVisitedChild = null;\n\n  namespace.exitTag(data.nodeName);\n\n  if (node.lastChild === lastVisitedChild) {\n    return;\n  }\n\n  while (node.lastChild !== lastVisitedChild) {\n    node.removeChild(node.lastChild);\n  }\n\n  // Invalidate the key map since we removed children. It will get recreated\n  // next time we need it.\n  data.keyMap = null;\n};\n\n\n/**\n * Marks node's parent as having visited node.\n * @param {!Node} node\n */\nvar markVisited = function(node) {\n  var walker = getWalker();\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function() {\n  var walker = getWalker();\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function() {\n  var walker = getWalker();\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function() {\n  var walker = getWalker();\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\n\n/** */\nmodule.exports = {\n  firstChild: firstChild,\n  nextSibling: nextSibling,\n  parentNode: parentNode,\n  markVisited: markVisited\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/traversal.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @type {TreeWalker}\n */\nvar walker_;\n\n\n/**\n * @return {TreeWalker} the current TreeWalker\n */\nvar getWalker = function() {\n  return walker_;\n};\n\n\n/**\n * Sets the current TreeWalker\n * @param {TreeWalker} walker\n */\nvar setWalker = function(walker) {\n  walker_ = walker;\n};\n\n\n/** */\nmodule.exports = {\n  getWalker: getWalker,\n  setWalker: setWalker\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/walker.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {?string} nodeName\n * @param {?string} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = {};\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = {};\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key || null;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, Node>}\n   */\n  this.keyMap = null;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @const {string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {!Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {!Node} node The node to retrieve the data for.\n * @return {NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/**\n * @param {?Node} node A node to get the key for.\n * @return {?string} The key for the Node, if applicable.\n */\nvar getKey = function(node) {\n  return getData(node).key;\n};\n\n\n/**\n * @param {?Node} node A node to get the node name for.\n * @return {?string} The node name for the Node, if applicable.\n */\nvar getNodeName = function(node) {\n  return getData(node).nodeName;\n};\n\n\n/** */\nmodule.exports = {\n  getData: getData,\n  initData: initData,\n  getKey: getKey,\n  getNodeName: getNodeName\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/node_data.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getWalker = require('./walker').getWalker;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function(tag) {\n  if (tag === 'svg') {\n    getWalker().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getWalker().enterNamespace(undefined);\n  }\n};\n\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function(tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getWalker().exitNamespace();\n  }\n};\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getWalker().getCurrentNamespace();\n};\n\n\n/** */\nmodule.exports = {\n  enterTag: enterTag,\n  exitTag: exitTag,\n  getNamespaceForTag: getNamespaceForTag\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/namespace.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Node} node The root Node of the subtree the walker should start\n *     traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /** {?Node} */\n  this.currentNode = node;\n\n  /** {!Document} */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @const @private {!Array<string>}\n   */\n  this.nsStack_ = [undefined];\n}\n\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function() {\n  return this.stack_[this.stack_.length - 1];\n};\n\n\n/**\n * @return {string} The current namespace to create Elements in.\n */\nTreeWalker.prototype.getCurrentNamespace = function() {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n\n/**\n * @param {string} namespace The namespace to enter.\n */\nTreeWalker.prototype.enterNamespace = function(namespace) {\n  this.nsStack_.push(namespace);\n};\n\n\n/**\n * Exits the current namespace\n */\nTreeWalker.prototype.exitNamespace = function() {\n  this.nsStack_.pop();\n};\n\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function() {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function() {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function() {\n  this.currentNode = this.stack_.pop();\n};\n\n\n/** */\nmodule.exports = TreeWalker;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/tree_walker.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar alignWithDOM = require('./alignment').alignWithDOM;\nvar updateAttribute = require('./attributes').updateAttribute;\nvar getData = require('./node_data').getData;\nvar getWalker = require('./walker').getWalker;\nvar traversal = require('./traversal'),\n    firstChild = traversal.firstChild,\n    nextSibling = traversal.nextSibling,\n    parentNode = traversal.parentNode;\n\nvar isTrackingRootElement = false;\nvar rootElement;\n\nfunction trackRoot() {\n  isTrackingRootElement = true;\n  rootElement = null;\n}\n\nfunction getRoot() {\n  return rootElement;\n}\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @type {Array<*>}\n * @const\n */\nvar argsBuilder = [];\n\n/**\n * Verify if the script are running in production.\n * @type {boolean}\n * @const\n */\nvar IS_PRODUCTION = process.env.NODE_ENV === 'production';\n\nif (!IS_PRODUCTION) {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function() {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n          'they must follow a call to elementOpenStart.');\n    }\n  };\n\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function() {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n          'elementOpenStart must be followed by zero or more calls to attr, ' +\n          'then one call to elementOpenEnd.');\n    }\n  };\n\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function() {\n    inAttributes = true;\n  };\n\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function() {\n    inAttributes = false;\n  };\n}\n\n\n/**\n * Checks to see if one or more attributes have changed for a given\n * Element. When no attributes have changed, this function is much faster than\n * checking each individual argument. When attributes have changed, the overhead\n * of this function is minimal.\n *\n * This function is called in the context of the Element and the arguments from\n * elementOpen-like function so that the arguments are not de-optimized.\n *\n * @this {Element} The Element to check for changed attributes.\n * @param {*} unused1\n * @param {*} unused2\n * @param {*} unused3\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {boolean} True if the Element has one or more changed attributes,\n *     false otherwise.\n */\nvar hasChangedAttrs = function(unused1, unused2, unused3, var_args) {\n  var data = getData(this);\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  return attrsChanged;\n};\n\n\n/**\n * Updates the newAttrs object for an Element.\n *\n * This function is called in the context of the Element and the arguments from\n * elementOpen-like function so that the arguments are not de-optimized.\n *\n * @this {Element} The Element to update newAttrs for.\n * @param {*} unused1\n * @param {*} unused2\n * @param {*} unused3\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Object<string, *>} The updated newAttrs object.\n */\nvar updateNewAttrs = function(unused1, unused2, unused3, var_args) {\n  var node = this;\n  var data = getData(node);\n  var newAttrs = data.newAttrs;\n\n  for (var attr in newAttrs) {\n    newAttrs[attr] = undefined;\n  }\n\n  for (var i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n    newAttrs[arguments[i]] = arguments[i + 1];\n  }\n\n  return newAttrs;\n};\n\n\n/**\n * Updates the attributes for a given Element.\n * @param {!Element} node\n * @param {!Object<string,*>} newAttrs The new attributes for node\n */\nvar updateAttributes = function(node, newAttrs) {\n  for (var attr in newAttrs) {\n    updateAttribute(node, attr, newAttrs[attr]);\n  }\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n */\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM(tag, key, statics);\n\n  if(isTrackingRootElement && !rootElement) {\n    rootElement = node;\n  }\n\n  if (hasChangedAttrs.apply(node, arguments)) {\n    var newAttrs = updateNewAttrs.apply(node, arguments);\n    updateAttributes(node, newAttrs);\n  }\n\n  firstChild();\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (!IS_PRODUCTION) {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n */\nvar elementOpenEnd = function() {\n  if (!IS_PRODUCTION) {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n */\nvar elementClose = function(tag) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  parentNode();\n  nextSibling();\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string} value The text of the Text.\n */\nvar text = function(value) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM('#text', null, value);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    node.data = value;\n    data.text = value;\n  }\n\n  nextSibling();\n};\n\n\n/** */\nmodule.exports = {\n  elementOpenStart: elementOpenStart,\n  elementOpenEnd: elementOpenEnd,\n  elementOpen: elementOpen,\n  elementVoid: elementVoid,\n  elementClose: elementClose,\n  text: text,\n  attr: attr,\n\n  // WIP: for component api\n  trackRoot: trackRoot,\n  getRoot: getRoot\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/virtual_elements.js\n ** module id = 13\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/process/browser.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar nodes = require('./nodes'),\n    createNode = nodes.createNode,\n    getChild = nodes.getChild,\n    registerChild = nodes.registerChild;\nvar nodeData = require('./node_data'),\n    getKey = nodeData.getKey,\n    getNodeName = nodeData.getNodeName;\nvar getWalker = require('./walker').getWalker;\n\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(node, nodeName, key) {\n  if (key) {\n    return key === getKey(node);\n  }\n  return nodeName === getNodeName(node);\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {?string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string} key The key used to identify this element.\n * @param {?Array<*>|string} statics For an Element, this should be an array of\n *     name-value pairs. For a Text, this should be the text content of the\n *     node.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  var walker = getWalker();\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = key && getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(walker.doc, nodeName, key, statics);\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n    }\n\n    parent.insertBefore(matchingNode, currentNode);\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n\n/** */\nmodule.exports = {\n  alignWithDOM: alignWithDOM,\n\n  // WIP: for component api\n  getMatchingNode: function(nodeName, key) {\n    var walker = getWalker();\n    var currentNode = walker.currentNode;\n\n    // Check to see if we have a node to reuse\n    if(currentNode && matches(currentNode, nodeName, key)) return currentNode;\n\n    return key && getChild(walker.getCurrentParent(), key);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/alignment.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar updateAttribute = require('./attributes').updateAttribute;\nvar nodeData = require('./node_data'),\n    getData = nodeData.getData,\n    getKey = nodeData.getKey,\n    initData = nodeData.initData;\nvar getNamespaceForTag = require('./namespace').getNamespaceForTag;\n\n\n/**\n * Creates an Element.\n * @param {!Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text.\n * @param {!Document} doc The document with which to create the Text.\n * @param {string} text The initial content of the Text.\n * @return {!Text}\n */\nvar createTextNode = function(doc, text) {\n  var node = doc.createTextNode(text);\n  getData(node).text = text;\n\n  return node;\n};\n\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {!Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>|string} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element. For a Text, a string with the\n *     initial content of the Text.\n * @return {!Node}\n */\nvar createNode = function(doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return createTextNode(doc, statics);\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Element} el\n * @return {!Object<string, !Node>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = {};\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getKey(child);\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Element} el\n * @return {!Object<string,!Node>} A mapping of keys to child Nodes\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Element} parent\n * @param {?string} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return getKeyMap(parent)[key];\n};\n\n\n/**\n * Registers a node as being a child. The parent will keep track of the child\n * using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Element} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nmodule.exports = {\n  createNode: createNode,\n  getChild: getChild,\n  registerChild: registerChild\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/nodes.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getData = require('./node_data').getData;\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is a object\n * or a function (which includes null), it is set as a property on the Element.\n * Otherwise, the value is set as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is a string, it is set\n *     as an HTML attribute, otherwise, it is set on node.\n */\nvar applyAttr = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var type = typeof value;\n\n  if (value === undefined) {\n    el.removeAttribute(name);\n  } else if (type === 'object' || type === 'function') {\n    el[name] = value;\n  } else {\n    el.setAttribute(name, value);\n  }\n\n  attrs[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string|Object<string,string>} style The style to set. Either a string\n *     of css or an object containing property-value pairs.\n */\nvar applyStyle = function(el, style) {\n  if (typeof style === 'string' || style instanceof String) {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n\n    for (var prop in style) {\n      el.style[prop] = style[prop];\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is a string, it is set\n *     as an HTML attribute, otherwise, it is set on node.\n */\nvar updateAttribute = function(el, name, value) {\n  if (name === 'style') {\n    applyStyle(el, value);\n  } else {\n    applyAttr(el, name, value);\n  }\n};\n\n\n/** */\nmodule.exports = {\n  updateAttribute: updateAttribute\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/incremental-dom/src/attributes.js\n ** module id = 17\n ** module chunks = 0\n **/","import stateful from '../helpers/stateful';\n\n// import TodoItem   from './TodoItem.jsx';\n// import TodoFooter from './TodoFooter.jsx';\n//\n// function handleNewTodoKeyDown(){ }\n// function handleToggleAll(){ }\n// function handleToggle(){ }\n// function handleDestroy(){ }\n//\n// export default ()=>{\n//   let activeTodoCount = 0;\n//   let shownTodos      = [{id:1, completed:false, title:'Hilaaarious'}];\n//\n//   <div>\n// \t\t<header class=\"header\">\n// \t\t\t<h1>todos</h1>\n// \t\t\t<input\n// \t\t\t\tref=\"newField\"\n// \t\t\t\tclass=\"new-todo\"\n// \t\t\t\tplaceholder=\"What needs to be done?\"\n// \t\t\t\tonKeyDown={handleNewTodoKeyDown}\n// \t\t\t\tautoFocus={true} />\n// \t\t</header>\n// \t\t<section class=\"main\">\n// \t\t\t<input\n// \t\t\t\tclass=\"toggle-all\"\n// \t\t\t\ttype=\"checkbox\"\n// \t\t\t\tonChange={handleToggleAll}\n// \t\t\t\tchecked={activeTodoCount === 0} />\n// \t\t\t<ul class=\"todo-list\">\n//         {shownTodos.forEach(todo=>\n//           <TodoItem todo={todo} onToggle={handleToggle} onDestroy={handleDestroy}/>\n//         )}\n// \t\t\t</ul>\n// \t\t</section>\n//     <TodoFooter />\n//   </div>;\n// };\n\nconst Counter = stateful(\n  count=>count || 0,\n  ({key, name}, count, setState)=>{\n    <div key={key}>\n      <span>{count} {name} &nbsp;&nbsp;&nbsp;</span>\n      <button onclick={()=>setState(++count)}>Hello World</button>\n    </div>;\n  }\n);\n\n\nconst Counter2 = ({key, name}, count, setState)=>{\n  <div key={key}>\n    <span>{count || 'hello'} {name} &nbsp;&nbsp;&nbsp;</span>\n    <button onclick={()=>setState(++count)}>Hello World</button>\n  </div>;\n};\n\nconst list = Array.apply(null, {length: 100}).map(Number.call, Number);\n\nexport default ()=>{\n  <div>\n    {list.forEach(i=>{\n      <Counter key={i} name={'C' + i} />;\n    })}\n  </div>;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/components/App.jsx\n **/","/*\n\nAllows defining stateful components\n\nTODO:\n\n- Inject key into component element render\n\nRequirements:\n\n- Handle initial render\n- Handle parent re-render\n- Handle component re-render (setState called)\n\n*/\n\nexport default (reduce, render)=>{\n  let nodeName;\n\n  function statefulRender(props, node){\n    // Called by component to set the new state and\n    // re-render the component without re-rendering\n    // the whole document\n    function setState(newState){\n      const parentNode = node.parentNode;\n\n      node.statefulState = newState;\n      IncrementalDOM.patch(parentNode, ()=>{\n        // Skip over all siblings before component's element\n        let curNode = parentNode.firstChild;\n        while(curNode !== node){\n          IncrementalDOM.skipNextElement();\n          curNode = curNode.nextSibling;\n        }\n\n        render(props, newState, setState);\n\n        // Mark the last child as visited so IncrementalDOM\n        // doesn't truncate all sibling elements after the\n        // component's element\n        IncrementalDOM.markVisited(parentNode.lastChild);\n      });\n    }\n\n    const key = props && props.key;\n\n    // Try to find component's element\n    node = node || (nodeName && IncrementalDOM.getMatchingNode(nodeName, key));\n\n    // Initial render\n    if(!node){\n      // TODO(pwong): Call with props and previous state\n      const state = reduce();\n\n      // Tell IncrementalDOM to track the root (first)\n      // element rendered.  This will be considered the\n      // component's element.\n      IncrementalDOM.elementTrackRoot();\n      render(props, state, setState);\n      node = IncrementalDOM.elementGetRoot();\n      // debugger;\n      // nodeName = node.nodeName.toLowerCase();\n      node.statefulState = state;\n    }\n    // Parent re-render\n    else{\n      render(props, node.statefulState, setState);\n    }\n  }\n\n  return statefulRender;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers/stateful.js\n **/"],"sourceRoot":""}